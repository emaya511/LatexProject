\documentclass[main.tex]{subfiles}



\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
%Code listing style named "mystyle"
\lstdefinestyle{mystyle}
{
	backgroundcolor=\color{backcolour},   commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	%   keepspaces=true,                 
	%numbers=false,                    
	%numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}
\lstset{style=mystyle}


%\lstset{language=Matlab,%
%    %basicstyle=\color{red},
%    breaklines=true,%
%    morekeywords={matlab2tikz},
%    keywordstyle=\color{blue},%
%    morekeywords=[2]{1}, keywordstyle=[2]{\color{black}},
%    identifierstyle=\color{black},%
%    stringstyle=\color{mylilas},
%    commentstyle=\color{mygreen},%
%    showstringspaces=false,%without this there will be a symbol in the places where there is a space
%    %numbers=left,%
%    %numberstyle={\tiny \color{black}},% size of the numbers
%    %numbersep=9pt, % this defines how far the numbers are from the text
%    emph=[1]{for,end,break},emphstyle=[1]\color{red}, %some words to emphasise
%    %emph=[2]{word1,word2}, emphstyle=[2]{style},    
%}




%\codeword{hello}


\begin{document}
\chapter{User Guide for FEM MATLAB Code}

This Guide is intended to provide basic instruction to use to \codeword{PLATE\_FEM} finite element code. The basic structure of the \codeword{PLATE\_FEM} is based on the Object Oriented Programming type where it contains many sub-classes inherited from few super-classes. All the class definitions are defined in a single folder named \codeword{PLATE\_FEM}. To access these classes, Either run the script file in same folder or the folder can be placed in one of the MATLAB paths. In case of creating a user defined MATLAB path, use the option \codeword{Home - Set Path - Add folder} to locate the \codeword{PLATE\_FEM} folder.

\subsubsection{Prerequisite files}
Mesh file and Material properties file are a must to run the FEM program. Mesh file is generated by GMSH pre-processing tool with the file format \codeword{.MSH}. For the Material property input user type file must be placed in the working directory. It is recommended to use to file name \codeword{Mat.dat.txt}. The content of a example MatDat file is given below.  It is highly insisted to follow this format. Currently, Linear Isotropic material is only supported.

%\VerbatimInput{codes/Mat.dat.txt}
\lstinputlisting{codes/Mat.dat.txt}

 
\subsubsection{Initiating the program}

%\lstinputlisting{codes/Dyna.m}
Since \codeword{PLATE\_FEM} code generate many output files, It is advised to create a separate a folder for each simulation and place all the prerequisite  files in the same folder or any of the sub folders. Run the Matlab script file from this working folder. It is highly advised to clear all pre-exisiting data.
\begin{lstlisting}[language=matlab]
clear;
clc;
\end{lstlisting}

To initiate the study, create an object of the class that corresponds to the indented study. \codeword{STATIC}, \codeword{MODAL} and \codeword{DYNAMIC} are the different existing simulation types. All of them inherits from the super class \codeword{PLATE\_FEM}. 
\begin{lstlisting}[language=matlab]
FEM=DYNAMIC("studyname");	    % To create a  dynamic study
FEM=MODAL("studyname");	                % To find a natural frequency
FEM=STATIC("studyname");	            % To solve static problem
\end{lstlisting}
If the script is re-run with same \codeword{studyname}, it will overwrite all existing data. To prevent overwriting either change the \codeword{studyname} or run it in a different folder. In order to import the material data file and mesh file. Code given below should be used.
\begin{lstlisting}[language=matlab]
FEM.ReadMesh("strip_tri.msh");      % Mesh File Input
FEM.Mat(1)=MATDat("Mat.dat.txt");   % Material file name input
\end{lstlisting}
If the ReadMSH file is exceuted without a file name it will look for a mesh with \codeword{studyname}. If nothing is found it will throw an exception.
Multiple objects (\codeword{FEM.Mat(1) $\cdots$ FEM.Mat(n)}) of the class (\codeword{ MATDat}) can be created but currently only one material can be successfully applied to the element. Multiple material in a single domain can be applied but it is not fully tested. 

\subsubsection{Loads and Boundary condition definition}

\codeword{Dirichlet} class is used to impose boundary displacement. It has two sub-classes namely \codeword{DirichletOnPhyEn} and \codeword{DirichletOnNode}. Boundary condition definition must be given using the objects of either of the sub-classes. Basic layout of input is given below.
\begin{lstlisting}[language=matlab]
FEM.Up(iu1)  =DirichletOnPhyEn(FEM, PhyEn, NodalDOFS, value  );
FEM.Un(iu2)  =DirichletOnNode (FEM, Nodes, NodalDOFS, value );

   
% FEM = Object of the class PLATE_FEM 
% Up  = Object of DirichletOnPhyEn class 
% Un  = Object of DirichletOnNode class 
% iu1, iu2 = Dirichlet reference number (multiple boundary conditions can be applied for same study)
% PhyEn = Physical entities values (ex: [2] or [1 2 3] )
% PhyEn entity can be a point or line or area
% NodalDOFS = To set the degree of freedom for which the displacement is imposed ( ex:[1 0 0] Dirichlet specially on w displacement)
% value  = displacement value (if value = 0 fixed and value not equal to 0 means imposed displacement) 
\end{lstlisting}

Similar layout to the Dirichlet is used for the Neumann boundary condition. Two subclass are defined \codeword{NeumannOnPhyEn} and \codeword{NeumannOnNode}.  \codeword{NeumannOnPhyEn} can only apply transverse point load and transverse distributed load on a \codeword{PhyEn}. 

\begin{lstlisting}[language=matlab]
FEM.Np(in1)  =NeumannOnPhyEn(FEM, PhyEn, NodalDOFS, value  );
FEM.Nn(in2)  =NeumannOnNode (FEM, Nodes, NodalDOFS, value );

   
  
% FEM = Object of the class PLATE_FEM 
% Fp  = Object of NeumannOnPhyEn class 
% Fn  = Object of NeumannOnNode class 
% in1, in2 = Neumann reference number (multiple boundary conditions can be applied for same study)
% PhyEn = Physical entities values (ex: [2] or [1 2 3] )
% PhyEn entity can be a point , line and are
% NodalDOFS = To set the degree of freedom for which the displacement is imposed ( ex:[1 0 0] Dirichlet specially on w displacement)
% value  = displacement value (if value = 0 fixed and value not equal to 0 means imposed displacement) 
\end{lstlisting}

\subsubsection{Probe Definition}
Probes are used to measure the displacement value at a designated node or PhyEn or a coordinate. For each time step, the average value is stored. This data can be exported to a file or can be plotted. 

\begin{lstlisting}[language=matlab]
FEM.Pp(ip1)=ProbeOnPhyEn(PhyEn,NodalDOFS);
FEM.Pn(ip2)=ProbeOnNode(node,NodalDOFS);
FEM.Pc(ip3)=ProbeOnCod(coordinate,NodalDOFS);

  
% FEM = Object of the class PLATE_FEM 
% Pp  = Object of ProbeOnPhyEn class 
% Pn  = Object of ProbeOnNode class 
% Pc  = Object of ProbeOnCod class 
% ip1, ip2, ip3 = Neumann reference number (multiple multiple probes for same study)
% PhyEn = Physical entities values (ex: [2] or [1 2 3] multiple Phy definition will add the values of each node ) PhyEn can be a point or line or area. Probe with track the displacement of the nodes corresponding to the each PhyEn and gives the average value.
%node = Nodes to measure the value (ex: [23 25] multiple node definition will add the values of each node) 
% NodalDOFS = To set the degree of freedom for which the displacement is imposed ( ex:[1 0 0] Dirichlet specially on w displacement, multiple Nodal Dofs(ex:[1 1 0] or [1 1 1] ) will result in meaningless results )
%coordinate = coordinate at which the solution is measured (ex : (0.5,5) the coordinate must be in a nodal point or in a element edge, coordinates inside a element is not completely defined)
\end{lstlisting}
After solving the \codeword{DYNAMIC} or \codeword{STATIC} problems, below commands can be used to write the probe data file or to plot the data.      
\begin{lstlisting}[language=matlab]
FEM.WriteProbe();
FEM.PlotProbe();
\end{lstlisting}



\subsubsection{Special commands for \codeword{DYNAMIC} class}

Since dynamic problems require additional information to solve. Certain commands exist specially for DYNAMIC class. One such command is 
\begin{lstlisting}[language=matlab]
FEM.T=FEMTime(0.01,1);	%Solution time 1s,Time step size 0.01 
\end{lstlisting}
\codeword{FEMTime} class is like a solver clock. In here, we input the time step size and solution time. This class is created such that any modification with in the class will not affect any other functions of the program. So that, in the future automatic time stepping algorithms can be included.

\begin{lstlisting}[language=matlab]
t=linspace(0,10,2001);
x=sin(25*t);    
FEM.TS(1)=TimeSeries(t,x);
\end{lstlisting}
\codeword{TimeSeries} class is used to store external time varying data. The data can be from a file or from a function (like sin function given in this example). The object \codeword{FEM.TS(1)} of the class \codeword{TimeSeries} can be operated with the objects of the \codeword{Neumann} and \codeword{dirichlet} boundary conditions so that time varying loads can be applied. 

\begin{lstlisting}[language=matlab]
FEM.InitialX('zero');
FEM.InitialV('zero');
\end{lstlisting}
These commands are used to set the initial displacement and velocity for the \codeword{ DYNAMIC} problem. These commands are a must for the \codeword{DYNAMIC} problem. Currently, only \codeword{'zero'} initial displacement and velocity can be applied. For non-zero initial condition code modification is required.

\subsubsection{Applying Domain, loads and boundary condition}

In order to solve the problem, the area solution domain has to be defined. It includes all the 2D domain where loads are defines. Failing to do, might result in a singular matrix. Following commands is used to define the domain.
\begin{lstlisting}[language=matlab]
FEM.SetDomain(PhyEn,MatId,'element_type');

% PhyEn  = All the Area Physical entities (ex:[1 21 22 23 24])
%MatID = Material Id 
%element_type = type of element (ex:'QUAD4' or 'PAT')
\end{lstlisting}

Multiple \codeword{SetDomain} command can be used to define different material properties. But this functionality is not fully tested. To apply already defined Neumann and Dirichlet loads, following options are used.

 \begin{lstlisting}[language=matlab]
FEM.ApplyF(FEM.Np(1))
FEM.ImposeU( FEM. Un(1))
\end{lstlisting}

Same command can also be used to define operators between many of the objects. this functionality is described in next section. 

\subsubsection{Operations between \codeword{Neumann},\codeword{Dirichlet},\codeword{Probe},\codeword{TimeSeries},\codeword{FEMTime}}

\begin{table}[t]
\caption{Operator overloading reference table}
\label{Op_Tab}
\centering
\begin{tabular}{|l|l|l|l|}
\hline
$U+U=U$ 	&  $U+C=U$ 	& $U \times FT = U$ & $U \times C = U$  \\ \hline
 $U \times TS = U$ & $U \times P = U$ &  $F+F=F$ 	&  $F+C=F$  \\ \hline
 $F \times FT = F$ & $F \times C = F$ &  $F \times TS = F$ & $F \times P = F$  \\ \hline
 $P \times C = P$ & $P + P =P $ &  $P + C = P$ & $P - P = P$  \\ \hline
 $Int(P) = P$ ($\int P dt$)& $P / FT =P $ &  $P.forT(C)=P$ $(P(n+C))$ & $cos(FT) = FT$  \\ \hline
 $sin(FT) = FT$ & $FT *FT =FT $ &  $FT.forT(C)=FT$ $(FT(n+C))$ & $FT * C = FT$  \\ \hline
 $FT - FT = FT$ & & &   \\ \hline
\end{tabular}
\end{table}
Operator overloading between objects of different classes is provided which enables us to give complex boundary conditions with ease. Also enables us to provide relations between different variables of the FEM program. Table : \ref{Op_Tab} shows all the enabled operators. The right hand side of the operations in the table denotes the return object type. 

U = \codeword{Dirichlet},\codeword{DirichletOnNode} and \codeword{DirichletOnPhyEn}\\
F = \codeword{Neumann},\codeword{NeumannOnNode} and \codeword{NeumannOnPhyEn}\\
P = \codeword{Probe},\codeword{ProbeOnNode},\codeword{ProbeOnCod} and \codeword{ProbeOnPhyEn}\\
TS = \codeword{TimeSeries}\\
FT = \codeword{FEMTime}\\
C = Any double (ex:C=2)



For example, in order to apply sinusoidal Dirichlet boundary condition one of the following snippets can be used.

\begin{lstlisting}[language=matlab]
t=linspace(0,10,2001);
x1=sin(25*t);  
    
FEM.TS(1)=TimeSeries(t,x1);
FEM.Up(2)=DirichletOnPhyEn(FEM, [11], [1 0 0], 0.01 );
FEM.ImposeU( FEM. Up(2)  *  FEM.TS(1)  );
\end{lstlisting}

\begin{center}
(or)
\end{center}


\begin{lstlisting}[language=matlab]
FEM.T=FEMTime(0.01,3);

FEM.Up(2)=DirichletOnPhyEn(FEM, [11], [1 0 0], 0.01 );
FEM.ImposeU( FEM. Up(2)  *  sin(40*FEM.T));
\end{lstlisting}To input general control formula given in the equation : \ref{eq:control}, following code snippet can be used. 

\begin{equation}\label{eq:control}
F(t_{n+1})=-(K_1 \cdot U(t_{n})+K_2\cdot\frac{\text{d}U}{\text{d}t}+K_3\cdot\int_{t_0}^{t_n} U dt)
\end{equation}

\begin{lstlisting}[language=matlab]

FEM.Pp(1)=ProbeOnPhyEn([21 22 23 24],[1 0 0]);
FEM.T=FEMTime(0.01,3);
    
FEM.Fp(1)=NeumannOnPhyEn(FEM, [22 23 24 21], [1 0 0], 1);

K1=10;      K2=2;      K3=10;
    
P1 = K1 * FEM.Pp(1).forT(0);
P2 = K2 *(FEM.Pp(1).forT(0)-FEM.Pp(1).forT(-1))/(FEM.T.forT(0)-FEM.T.forT(-1));
P3 = K3 * Int(FEM.Pp(1));
FEM.ApplyF( -1 *  FEM.Fp(1)  * (P1 + P2 + P3) );
\end{lstlisting}




\subsubsection{Solution}
\begin{lstlisting}[language=matlab]
FEM.Solve();
\end{lstlisting}
This is a common command for all three sub-classes  \codeword{STATIC}, \codeword{MODAL} and \codeword{DYNAMIC}. This command will run the basic solution routine of the corresponding sub-class. For \codeword{STATIC} there are no additional options available. But for \codeword{MODAL}, two solution procedure are available. Just using the command \codeword{FEM.Solve();} will solve the Eigen problem using \codeword {eig()} function. This function calculates all the Eigen modes and values, which is very expensive. But sending a constant  like this \codeword{FEM.Solve(20);}, makes use of  \codeword {eigs()} function. \codeword {eigs()} option only explores the subspace of the full eigen space.\codeword{FEM.Solve(20);} command will only calculate first 20 natural frequency and modes.

For the \codeword{DYNAMIC} class, \codeword{FEM.Solve();} will solve the system with regular Newmark algorithm (refereed from ANSYS theory manual) given below but this is an expensive operation. 
\begin{equation*}
R=F_t + \mathbf{M} \left(a_0 u_{t}+a_2 v_{t} + a_3 a_{t} \right) + \mathbf{C} \left(a_1 u_{t}+a_4 v_{t} + a_5 a_{t} \right) 
\end{equation*}
\begin{equation*}
u_{t+1}=\left[a_0 \mathbf{M} + a_1 \mathbf{C} + \mathbf{K} \right] ^ {-1} R
\end{equation*}
\begin{equation*}
v_{t+1}=a_1 \left( u_{t+1} - u_{t} \right) - a_4 v_t -a_5 a_t
\end{equation*}
\begin{equation*}
a_{t+1}=a_0 \left( u_{t+1} - u_{t}\right) - a_2 v_t -a_3 a_t
\end{equation*}
\begin{align*}
&a_0 = \frac{1}{\alpha h^2}& 
&a_1 = \frac{\theta}{\alpha h} & 
&a_2 = \frac{1}{\alpha h} \\
&a_3 = \frac{1}{2 \alpha }-1 &  
&a_4 = \frac{\theta}{\alpha} & 
& a_5 = \frac{h}{2} \frac{\theta}{\alpha}-2
\end{align*}
\begin{align*}
\theta & \geq \frac{1}{2}  \\
\alpha & \geq \frac{1}{4}\left(\frac{1}{2}+\theta \right)^2
\end{align*}
The problem with constant time step size and time independent material property, the matrix that need to be inverted does not change for each time step. we can exploit this feature to increase the solution speed. The matrix needed to be inverted is pre-factorized, which increases the efficiency to many fold. To use this feature, following command is used.
\begin{lstlisting}[language=matlab]
FEM.SolveLU();
\end{lstlisting}
Still this matrix is large and takes lots of time to solve. To further increase the solution speed Modal - superposition  technique is used.
 \begin{lstlisting}[language=matlab]
FEM.SolveLU_RED(n_base);
\end{lstlisting}
Command will construct \codeword{n\_base}number of reduced basis and project the basis to the full matrix. This only leave the system with   (\codeword{n\_base}) unknowns. To decide the number of (\codeword{n\_base}), it is highly recommended to run the \codeword{MODAL} analysis with the command \codeword{FEM.Solve(n\_base);} and see if the highest natural frequency is well within the safety limit. 

\subsubsection{Exporting to state-space form}
 In order to use the finite element system model with the Simulink module.  the FEM ODE is exported into State-Space form using the command.
 \begin{lstlisting}[language=matlab]
 [A_DF,B_DF,C_DF,D_DF]=FEM.GetMat_RED(n_bas)
 \end{lstlisting}
 This command will export the reduced model with (\codeword{n\_bas}) number of states. Since the full model is very large so it is very hard to converge. Once solved using Simulink, the results can be extracted and stored in FE matrix format using 
  \begin{lstlisting}[language=matlab]
 FEM.ExtractFromSS(Strip1DState) 
  \end{lstlisting}
  
\subsubsection{Writing Pos file}

  \begin{lstlisting}[language=matlab]
 FEM.WritePos() 
  \end{lstlisting}
  
  Command will write the solution in a format compatible with the GMSH tool. For the \codeword{MODAL} analysis, additional input in this command will let us only store the required natural modes.
  
    \begin{lstlisting}[language=matlab]
 FEM.WritePos([1 2 3 5 10]) 
  \end{lstlisting}


 

\subsubsection{Additional Options}

By default, \codeword{PLATE\_FEM} command stores all matrix in full matrix format, since full matrix format is faster and easy to display. But the full matrix format will occupy very large memory. This sometimes results in  \codeword{MEMORY ERROR}. To prevent this error, the major matrices can stored in a sparse matrix format. To enable this option, go to the file \codeword{PLATE\_FEM} and in the properties section, change \codeword{issparse = 0;} into \codeword{issparse = 1;}. 

In the \codeword{PLATE\_FEM}, by default only point, line , triangle and quadrangle elements are enabled. To turn on or off any new or existing element, go to the file \codeword{FEMMesh}. In the constructor function, find \codeword{elemprop1.access} and type  '1' to turn on and '0' to off the element in the corresponding location.

\codeword{PLATE\_FEM} program output a log file, which helps in tracking the progress of the solution. If the log data is not required to be displayed in the command window, it can be turned off by typing \codeword{obj.displayon=on;} in the \codeword{LG} file constructor. 


\end{document}